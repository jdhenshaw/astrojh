#==============================================================================#
# acornstools.py
#==============================================================================#
import numpy as np
from astropy.io import fits
import os
import glob
from astropy.utils.console import ProgressBar
from acorns import Acorns
from astropy.table import Table
from astropy.table import Column
import sys

def cubetrim(cube, ppv_vol):
    """
    Trims a cube according to scousepy ppv_vol trim Parameters

    Parameters
    ----------
    cube : spectralcube data cube
        Data cube generated by spectral cube
    ppv_vol : ndarray
        array of limits for cube trimming format should be:
        ppv_vol = [vmin, vmax, ymin, ymax, xmin, xmax]

    """

    velaxis = np.array(cube.world[:,0,0][0])
    if (ppv_vol[0] is not None) & (ppv_vol[1] is not None):
        trimids = np.where((velaxis>ppv_vol[0])&(velaxis<ppv_vol[1]))[0]

    if ppv_vol[0] is None:
        ppv_vol[0]=0
    else:
        ppv_vol[0]=np.min(trimids)
    if ppv_vol[1] is None:
        ppv_vol[1]=cube.shape[0]
    else:
        ppv_vol[1]=np.max(trimids)

    if ppv_vol[2] is None:
        ppv_vol[2]=0
    if ppv_vol[3] is None:
        ppv_vol[3]=cube.shape[1]

    if ppv_vol[4] is None:
        ppv_vol[4]=0
    if ppv_vol[5] is None:
        ppv_vol[5]=cube.shape[2]

    cube = cube[int(ppv_vol[0]):int(ppv_vol[1]),
                int(ppv_vol[2]):int(ppv_vol[3]),
                int(ppv_vol[4]):int(ppv_vol[5])]

    return cube

def acornstofits(x, y, z, cube, write_fits=True,
                 outputdir='./', outputfile='image.fits',
                 datatype='', dataunit='',
                 ppv_vol=[None,None,None,None,None,None],
                 mask=False):
    """
    Accepts an array of acorns data as well as the original information
    regarding fitting (PPV_vol if using scousepy for example), and the original
    cube and creates an image of the required data. Returns a 2-D image of the
    data but a fitsfile can be created as an option. NB: this code assumes the
    input data is in pixel coordinates - use acornstofits_wcs if the input is
    in wcs coords.

    Parameters
    ----------
    x : ndarray
        array of x positions
    y : ndarray
        array of y positions
    z : ndarray
        data for image
    cube : spectralcube data cube
        Data cube generated by spectral cube
    write_fits : bool
        whether or not you want to output to fits (default==True)
    outputdir : string
        output directory (default will be current directory)
    outputfile : string
        output file name (default is image.fits)
    datatype : string
        To be added to the fits header e.g. intensity, velocity, dispersion etc
    dataunit : string
        Unit of the data
    ppv_vol : ndarray
        array of limits for cube trimming format should be:
        ppv_vol = [vmin, vmax, ymin, ymax, xmin, xmax]
    mask : bool
        if True will simply create a mask of the acorns cluster

    """

    cube = cubetrim(cube, ppv_vol)
    dataarr = np.empty(cube.shape[1::])

    if mask:
        dataarr[:,:]=0
        z = np.ones_like(z)
        if not os.path.exists(outputdir):
            os.makedirs(outputdir)
    else:
        dataarr[:,:]=np.NaN

    for i in range(len(x)):
        dataarr[int(y[i]), int(x[i])]=z[i]

    # output to fits if wanted
    if write_fits:
        header = cube.header
        header['BUNIT']=dataunit
        header['BTYPE']=datatype
        header.remove('CRPIX3')
        header.remove('CRVAL3')
        header.remove('CDELT3')
        header.remove('CUNIT3')
        header.remove('CTYPE3')

        hdu = fits.PrimaryHDU(dataarr, header=header)
        hdu.writeto(outputdir+outputfile, overwrite=True)

    return dataarr

def combine_masks(maskdir, outputdir='./', outputfile='mastermask.fits',
                  write_fits=True):
    """
    Will take all masks contained within a directory and combine them into a
    single mask

    Parameters
    ----------
    maskdir : string
        directory containing the masks you would like to combine. Masks need to
        be in fits format
    outputdir : string (optional)
        output directory (default will be current directory)
    outputfile : string (optional)
        output file name (default is mastermask.fits)
    write_fits : bool
        whether or not you want to output to fits (default==True)
    """
    input_files = glob.glob(maskdir+'*.fits')
    mask = fits.getdata(input_files[0], header=True)
    header=mask[1]
    mastermask=np.zeros_like(mask[0])
    for file in ProgressBar(input_files):
        mask = fits.getdata(file, header=False)
        mastermask+=mask

    if write_fits:
        hdu = fits.PrimaryHDU(mastermask, header=header)
        hdu.writeto(outputdir+outputfile, overwrite=True)

    return mastermask

def get_leaf_positions(acorn, outputdir='./', outputfile='leafpositions.dat',
                       clipbelow=None):
    """
    Reads in an acorn and outputs the positions of all the leaves

    Parameters
    ----------
    acorn : acorns output file
        acorns output file
    outputdir : string (optional)
        output directory (default will be current directory)
    outputfile : string (optional)
        output file name (default is leafpositions.dat)
    clipbelow : float
        Will clip all leaves whose peak flux sits below this value
    """
    A = Acorns.load_from(acorn)
    xpeaks=[]
    ypeaks=[]
    for tree in A.forest:
        for leaf in A.forest[tree].leaves:
            peakvalue = leaf.statistics[0][1]
            if clipbelow is not None:
                if peakvalue > clipbelow:
                    peakloc = leaf.peak_location
                    xpeaks.append(peakloc[0])
                    ypeaks.append(peakloc[1])
            else:
                peakloc = leaf.peak_location
                xpeaks.append(peakloc[0])
                ypeaks.append(peakloc[1])

    headings=['x position', 'y position']
    table = Table(meta={'name':'leaf peak positions'})
    table['x position'] = Column(xpeaks)
    table['y position'] = Column(ypeaks)
    table.write(outputfile, format='ascii', overwrite=True)

    return xpeaks,ypeaks
